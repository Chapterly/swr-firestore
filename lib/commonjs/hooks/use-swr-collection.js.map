{"version":3,"sources":["use-swr-collection.ts"],"names":["getCollection","path","query","empty","object","parseDates","ignoreFirestoreDocumentSnapshotField","ref","createFirestoreRef","get","then","querySnapshot","array","forEach","doc","docData","data","serverTimestamps","docToAdd","id","exists","hasPendingWrites","metadata","__snapshot","undefined","isDev","console","warn","push","where","orderBy","limit","startAt","endAt","startAfter","endBefore","isCollectionGroup","fuego","db","collection","collectionGroup","multipleConditions","w","Array","isArray","multipleOrderBy","o","order","direction","createListenerAsync","queryString","onSnapshotError","Promise","resolve","JSON","parse","unsubscribe","onSnapshot","includeMetadataChanges","initialData","error","useCollection","options","unsubscribeRef","listen","refreshInterval","refreshWhenHidden","refreshWhenOffline","revalidateOnFocus","revalidateOnReconnect","dedupingInterval","swrOptions","memoQueryString","stringify","dateParser","current","shouldListen","shouldIgnoreSnapshot","swr","FirestoreSWRError","message","mounted","revalidateRef","revalidate","collectionCache","addCollectionToCache","isValidating","mutate","add","dataArray","docsToAdd","map","prevState","state","batch","set","commit","loading"],"mappings":"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","sourcesContent":["import useSWR, { mutate as mutateStatic, ConfigInterface } from 'swr'\nimport { fuego } from '../context'\nimport { useRef, useEffect, useMemo, useCallback } from 'react'\n// import { useMemoOne as useMemo } from 'use-memo-one'\nimport { empty } from '../helpers/empty'\nimport { collectionCache } from '../classes/Cache'\n\n// type Document<T = {}> = T & { id: string }\n\nimport {\n  FieldPath,\n  OrderByDirection,\n  WhereFilterOp,\n  Query,\n} from '@firebase/firestore-types'\nimport { isDev } from '../helpers/is-dev'\nimport { withDocumentDatesParsed } from '../helpers/doc-date-parser'\nimport { Document } from '../types'\nimport { FirestoreSWRError } from \"../classes/FirestoreSWRError\";\n\ntype KeyHack = string & {} // hack to also allow strings\n\n// here we get the \"key\" from our data, to add intellisense for any \"orderBy\" in the queries and such.\ntype OrderByArray<Doc extends object = {}, Key = keyof Doc> = [\n  Key | FieldPath | KeyHack,\n  OrderByDirection\n]\ntype OrderByItem<Doc extends object = {}, Key = keyof Doc> =\n  | OrderByArray<Doc>\n  | Key\n  | KeyHack\ntype OrderByType<Doc extends object = {}> =\n  | OrderByItem<Doc>\n  | OrderByArray<Doc>[]\n\ntype WhereItem<Doc extends object = {}, Key = keyof Doc> = [\n  Key | FieldPath | KeyHack,\n  WhereFilterOp,\n  unknown\n]\ntype WhereArray<Doc extends object = {}> = WhereItem<Doc>[]\ntype WhereType<Doc extends object = {}> = WhereItem<Doc> | WhereArray<Doc>\n\nexport type CollectionQueryType<Doc extends object = {}> = {\n  limit?: number\n  orderBy?: OrderByType<Doc>\n  where?: WhereType<Doc>\n  isCollectionGroup?: boolean\n\n  /**\n   * For now, this can only be a number, since it has to be JSON serializable.\n   *\n   * **TODO** allow DocumentSnapshot here too. This will probably be used with a useStaticCollection hook in the future.\n   */\n  startAt?: number\n  /**\n   * For now, this can only be a number, since it has to be JSON serializable.\n   *\n   * **TODO** allow DocumentSnapshot here too. This will probably be used with a useStaticCollection hook in the future.\n   */\n  endAt?: number\n  /**\n   * For now, this can only be a number, since it has to be JSON serializable.\n   *\n   * **TODO** allow DocumentSnapshot here too. This will probably be used with a useStaticCollection hook in the future.\n   */\n  startAfter?: number\n  /**\n   * For now, this can only be a number, since it has to be JSON serializable.\n   *\n   * **TODO** allow DocumentSnapshot here too. This will probably be used with a useStaticCollection hook in the future.\n   */\n  endBefore?: number\n\n  // THESE ARE NOT JSON SERIALIZABLE\n  // startAt?: number | DocumentSnapshot\n  // endAt?: number | DocumentSnapshot\n  // startAfter?: number | DocumentSnapshot\n  // endBefore?: number | DocumentSnapshot\n}\n\nexport const getCollection = async <Doc extends Document = Document>(\n  path: string,\n  // queryString: string = '{}',\n  query: CollectionQueryType<Doc> = {},\n  {\n    parseDates,\n    ignoreFirestoreDocumentSnapshotField,\n  }: {\n    parseDates?: (string | keyof Doc)[]\n    /**\n     * If `true`, docs returned in `data` will not include the firestore `__snapshot` field. If `false`, it will include a `__snapshot` field. This lets you access the document snapshot, but makes the document not JSON serializable.\n     *\n     * Default: `false`\n     */\n    ignoreFirestoreDocumentSnapshotField?: boolean\n  } = empty.object\n) => {\n  const ref = createFirestoreRef(path, query)\n  const data: Doc[] = await ref.get().then(querySnapshot => {\n    const array: typeof data = []\n    querySnapshot.forEach(doc => {\n      const docData =\n        doc.data({\n          serverTimestamps: 'estimate',\n        }) ?? empty.object\n      const docToAdd = withDocumentDatesParsed(\n        {\n          ...docData,\n          id: doc.id,\n          exists: doc.exists,\n          hasPendingWrites: doc.metadata.hasPendingWrites,\n          __snapshot: ignoreFirestoreDocumentSnapshotField ? undefined : doc,\n        } as any,\n        parseDates\n      )\n      // update individual docs in the cache\n      mutateStatic(doc.ref.path, docToAdd, false)\n      if (\n        isDev &&\n        // @ts-ignore\n        (docData.exists || docData.id || docData.hasPendingWrites)\n      ) {\n        console.warn(\n          '[get-collection] warning: Your document, ',\n          doc.id,\n          ' is using one of the following reserved fields: [exists, id, hasPendingWrites]. These fields are reserved. Please remove them from your documents.'\n        )\n      }\n      array.push(docToAdd)\n    })\n    return array\n  })\n  return data\n}\n\nconst createFirestoreRef = <Doc extends object = {}>(\n  path: string,\n  {\n    where,\n    orderBy,\n    limit,\n    startAt,\n    endAt,\n    startAfter,\n    endBefore,\n    isCollectionGroup,\n  }: CollectionQueryType<Doc>\n) =>\n  // { isCollectionGroup = false }: { isCollectionGroup?: boolean } = empty.object\n  {\n    let ref: Query = fuego.db.collection(path)\n\n    if (isCollectionGroup) {\n      ref = fuego.db.collectionGroup(path)\n    }\n\n    if (where) {\n      function multipleConditions(w: WhereType<Doc>): w is WhereArray<Doc> {\n        return !!(w as WhereArray) && Array.isArray(w[0])\n      }\n      if (multipleConditions(where)) {\n        where.forEach(w => {\n          ref = ref.where(w[0] as string | FieldPath, w[1], w[2])\n        })\n      } else if (typeof where[0] === 'string' && typeof where[1] === 'string') {\n        ref = ref.where(where[0], where[1], where[2])\n      }\n    }\n\n    if (orderBy) {\n      if (typeof orderBy === 'string') {\n        ref = ref.orderBy(orderBy)\n      } else if (Array.isArray(orderBy)) {\n        function multipleOrderBy(\n          o: OrderByType<Doc>\n        ): o is OrderByArray<Doc>[] {\n          return Array.isArray((o as OrderByArray<Doc>[])[0])\n        }\n        if (multipleOrderBy(orderBy)) {\n          orderBy.forEach(([order, direction]) => {\n            ref = ref.orderBy(order as string | FieldPath, direction)\n          })\n        } else {\n          const [order, direction] = orderBy\n          ref = ref.orderBy(order as string | FieldPath, direction)\n        }\n      }\n    }\n\n    if (startAt) {\n      ref = ref.startAt(startAt)\n    }\n\n    if (endAt) {\n      ref = ref.endAt(endAt)\n    }\n\n    if (startAfter) {\n      ref = ref.startAfter(startAfter)\n    }\n\n    if (endBefore) {\n      ref = ref.endBefore(endBefore)\n    }\n\n    if (limit) {\n      ref = ref.limit(limit)\n    }\n\n    return ref\n  }\n\ntype ListenerReturnType<Doc extends Document = Document> = {\n  initialData: Doc[] | null\n  unsubscribe: ReturnType<ReturnType<typeof fuego['db']['doc']>['onSnapshot']>\n}\n\nconst createListenerAsync = async <Doc extends Document = Document>(\n  path: string,\n  queryString: string,\n  {\n    parseDates,\n    ignoreFirestoreDocumentSnapshotField = true,\n  }: // isCollectionGroup = false,\n  {\n    parseDates?: (string | keyof Doc)[]\n    /**\n     * If `true`, docs returned in `data` will not include the firestore `__snapshot` field. If `false`, it will include a `__snapshot` field. This lets you access the document snapshot, but makes the document not JSON serializable.\n     *\n     * Default: `true`\n     */\n    ignoreFirestoreDocumentSnapshotField?: boolean\n  },\n  onSnapshotError?: (error: Error) => void\n): Promise<ListenerReturnType<Doc>> => {\n  return new Promise(resolve => {\n    const query: CollectionQueryType = JSON.parse(queryString) ?? {}\n    const ref = createFirestoreRef(path, query)\n    const unsubscribe = ref.onSnapshot(\n      { includeMetadataChanges: true },\n      querySnapshot => {\n        const data: Doc[] = []\n        querySnapshot.forEach(doc => {\n          const docData =\n            doc.data({\n              serverTimestamps: 'estimate',\n            }) ?? empty.object\n          const docToAdd = withDocumentDatesParsed(\n            {\n              ...docData,\n              id: doc.id,\n              exists: doc.exists,\n              hasPendingWrites: doc.metadata.hasPendingWrites,\n              __snapshot: ignoreFirestoreDocumentSnapshotField\n                ? undefined\n                : doc,\n            } as any,\n            parseDates\n          )\n          if (\n            isDev &&\n            // @ts-ignore\n            (docData.exists || docData.id || docData.hasPendingWrites)\n          ) {\n            console.warn(\n              '[use-collection] warning: Your document, ',\n              doc.id,\n              ' is using one of the following reserved fields: [exists, id, hasPendingWrites]. These fields are reserved. Please remove them from your documents.'\n            )\n          }\n          // update individual docs in the cache\n          mutateStatic(doc.ref.path, docToAdd, false)\n          data.push(docToAdd)\n        })\n        // resolve initial data\n        resolve({\n          initialData: data,\n          unsubscribe,\n        })\n        // update on listener fire\n        mutateStatic([path, queryString], data, false)\n      },\n      (error) => {\n        if (onSnapshotError) {\n          onSnapshotError(error)\n        }\n      }\n    )\n  })\n}\n\nexport type CollectionSWROptions<\n  Doc extends Document = Document\n> = ConfigInterface<Doc[] | null>\n/**\n * Call a Firestore Collection\n * @template Doc\n * @param path String if the document is ready. If it's not ready yet, pass `null`, and the request won't start yet.\n * @param [query] - Dictionary with options to query the collection.\n * @param [options] - Dictionary with option `listen`. If true, it will open a socket listener. Also takes any of SWR's options.\n */\nexport const useCollection = <\n  Data extends object = {},\n  Doc extends Document = Document<Data>\n>(\n  path: string | null,\n  query: CollectionQueryType<Data> & {\n    /**\n     * If `true`, sets up a real-time subscription to the Firestore backend.\n     *\n     * Default: `false`\n     */\n    listen?: boolean\n    /**\n     * An array of key strings that indicate where there will be dates in the document.\n     *\n     * Example: if your dates are in the `lastUpdated` and `user.createdAt` fields, then pass `{parseDates: [\"lastUpdated\", \"user.createdAt\"]}`.\n     *\n     * This will automatically turn all Firestore dates into JS Date objects, removing the need to do `.toDate()` on your dates.\n     */\n    parseDates?: (string | keyof Doc)[]\n    /**\n     * If `true`, docs returned in `data` will not include the firestore `__snapshot` field. If `false`, it will include a `__snapshot` field. This lets you access the document snapshot, but makes the document not JSON serializable.\n     *\n     * Default: `true`\n     */\n    ignoreFirestoreDocumentSnapshotField?: boolean\n  } = empty.object,\n  options: CollectionSWROptions<Doc> = empty.object\n) => {\n  const unsubscribeRef = useRef<ListenerReturnType['unsubscribe'] | null>(null)\n\n  const {\n    where,\n    endAt,\n    endBefore,\n    startAfter,\n    startAt,\n    orderBy,\n    limit,\n    listen = false,\n    parseDates,\n    // __unstableCollectionGroup: isCollectionGroup = false,\n    isCollectionGroup,\n    ignoreFirestoreDocumentSnapshotField = true,\n  } = query\n\n  // if we're listening, the firestore listener handles all revalidation\n  const {\n    refreshInterval = listen ? 0 : undefined,\n    refreshWhenHidden = listen ? false : undefined,\n    refreshWhenOffline = listen ? false : undefined,\n    revalidateOnFocus = listen ? false : undefined,\n    revalidateOnReconnect = listen ? false : undefined,\n    dedupingInterval = listen ? 0 : undefined,\n  } = options\n\n  const swrOptions = {\n    ...options,\n    refreshInterval,\n    refreshWhenHidden,\n    refreshWhenOffline,\n    revalidateOnFocus,\n    revalidateOnReconnect,\n    dedupingInterval,\n  }\n\n  // why not just put this into the ref directly?\n  // so that we can use the useEffect down below that triggers revalidate()\n  const memoQueryString = useMemo(\n    () =>\n      JSON.stringify({\n        where,\n        endAt,\n        endBefore,\n        startAfter,\n        startAt,\n        orderBy,\n        limit,\n        isCollectionGroup,\n      }),\n    [\n      endAt,\n      endBefore,\n      isCollectionGroup,\n      limit,\n      orderBy,\n      startAfter,\n      startAt,\n      where,\n    ]\n  )\n\n  // we move this to a Ref\n  // why? because we shouldn't have to include it in the key\n  // if we do, then calling mutate() won't be consistent for all\n  // collections with the same path & query\n  // TODO figure out if this is the right behavior...probably not because of the paths. hm.\n  // TODO it's not, move this to the\n  // const isCollectionGroupQuery = useRef(isCollectionGroup)\n  // useEffect(() => {\n  //   isCollectionGroupQuery.current = isCollectionGroup\n  // }, [isCollectionGroup])\n\n  const dateParser = useRef(parseDates)\n  useEffect(() => {\n    dateParser.current = parseDates\n  }, [parseDates])\n\n  // we move listen to a Ref\n  // why? because we shouldn't have to include \"listen\" in the key\n  // if we do, then calling mutate() won't be consistent for all\n  // collections with the same path & query\n  const shouldListen = useRef(listen)\n  useEffect(() => {\n    shouldListen.current = listen\n  })\n\n  const shouldIgnoreSnapshot = useRef(ignoreFirestoreDocumentSnapshotField)\n  useEffect(() => {\n    shouldIgnoreSnapshot.current = ignoreFirestoreDocumentSnapshotField\n  }, [ignoreFirestoreDocumentSnapshotField])\n\n  const swr = useSWR<Doc[] | null>(\n    // if the path is null, this means we don't want to fetch yet.\n    path === null ? null : [path, memoQueryString],\n    async (path: string, queryString: string) => {\n      if (shouldListen.current) {\n        if (unsubscribeRef.current) {\n          unsubscribeRef.current()\n          unsubscribeRef.current = null\n        }\n        const { unsubscribe, initialData } = await createListenerAsync<Doc>(\n          path,\n          queryString,\n          {\n            parseDates: dateParser.current,\n            ignoreFirestoreDocumentSnapshotField: shouldIgnoreSnapshot.current,\n          },\n          (error) => {\n            throw new FirestoreSWRError(`useCollection onSnapshotError ${error.message} path ${path}`, path, queryString)\n          }\n        )\n        unsubscribeRef.current = unsubscribe\n        return initialData\n      }\n\n      const data = await getCollection<Doc>(\n        path,\n        JSON.parse(queryString) as CollectionQueryType<Doc>,\n        {\n          parseDates: dateParser.current,\n          ignoreFirestoreDocumentSnapshotField: shouldIgnoreSnapshot.current,\n        }\n      )\n      return data\n    },\n    swrOptions\n  )\n\n  // if listen or changes,\n  // we run revalidate.\n  // This triggers SWR to fetch again\n  // Why? because we don't want to put listen\n  // in the useSWR key. If we did, then we couldn't mutate\n  // based on query alone. If we had useSWR(['users', true]),\n  // but then a `users` fetch with `listen` set to `false` updated, it wouldn't mutate both.\n  // thus, we move the `listen` and option to a ref user in `useSWR`,\n  // and we call `revalidate` if it changes.\n  const mounted = useRef(false)\n  useEffect(() => {\n    // TODO should this only happen if listen is false? No, BC swr should revalidate on a change.\n    if (mounted.current) revalidateRef.current()\n    else mounted.current = true\n  }, [listen])\n\n  // this MUST be after the previous effect to avoid duplicate initial validations.\n  // only happens on updates, not initial mounting\n  const revalidateRef = useRef(swr.revalidate)\n  useEffect(() => {\n    revalidateRef.current = swr.revalidate\n  })\n\n  useEffect(() => {\n    // TODO should this only be for listen, since SWR updates with the others?\n    // also should it go before the useSWR?\n    return () => {\n      // clean up listener on unmount if it exists\n      if (unsubscribeRef.current) {\n        unsubscribeRef.current()\n        unsubscribeRef.current = null\n      }\n    }\n    // should depend on the path, queyr, and listen being the same...\n  }, [path, listen, memoQueryString])\n\n  // add the collection to the cache,\n  // so that we can mutate it from document calls later\n  useEffect(() => {\n    if (path) collectionCache.addCollectionToCache(path, memoQueryString)\n  }, [path, memoQueryString])\n\n  const { data, isValidating, revalidate, mutate, error } = swr\n\n  /**\n   * `add(data)`: Extends the Firestore document [`add` function](https://firebase.google.com/docs/firestore/manage-data/add-data).\n   * - It also updates the local cache using SWR's `mutate`. This will prove highly convenient over the regular `add` function provided by Firestore.\n   */\n  const add = useCallback(\n    (data: Data | Data[]) => {\n      if (!path) return null\n\n      const dataArray = Array.isArray(data) ? data : [data]\n\n      const ref = fuego.db.collection(path)\n\n      const docsToAdd: Doc[] = (dataArray.map(doc => ({\n        ...doc,\n        // generate IDs we can use that in the local cache that match the server\n        id: ref.doc().id,\n      })) as unknown) as Doc[] // solve this annoying TS bug ðŸ˜…\n\n      // add to cache\n      if (!listen) {\n        // we only update the local cache if we don't have a listener set up\n        // why? because Firestore automatically handles this part for subscriptions\n        mutate(prevState => {\n          const state = prevState ?? empty.array\n          return [...state, ...docsToAdd]\n        }, false)\n      }\n\n      // add to network\n      const batch = fuego.db.batch()\n\n      docsToAdd.forEach(({ id, ...doc }) => {\n        // take the ID out of the document\n        batch.set(ref.doc(id), doc)\n      })\n\n      return batch.commit()\n    },\n    [listen, mutate, path]\n  )\n\n  return {\n    data,\n    isValidating,\n    revalidate,\n    mutate,\n    error,\n    add,\n    loading: !data && !error,\n    /**\n     * A function that, when called, unsubscribes the Firestore listener.\n     *\n     * The function can be null, so make sure to check that it exists before calling it.\n     *\n     * Note: This is not necessary to use. `useCollection` already unmounts the listener for you. This is only intended if you want to unsubscribe on your own.\n     */\n    unsubscribe: unsubscribeRef.current,\n  }\n}\n"]}